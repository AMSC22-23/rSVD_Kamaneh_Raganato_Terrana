#include "AdvDiff1D_POD.hpp"

void
AdvDiffPOD::setup()
{
  // Create the mesh.
  {
    pcout << "Initializing the mesh" << std::endl;

    Triangulation<dim> mesh_serial;
    GridGenerator::subdivided_hyper_cube(mesh_serial, N + 1, 0.0, 1.0, true);
    pcout << "  Number of elements = " << mesh.n_active_cells()
              << std::endl;

    // Write the mesh to file.
    const std::string mesh_file_name = "mesh-" + std::to_string(N + 1) + ".vtk";
    GridOut           grid_out;
    std::ofstream     grid_out_file(mesh_file_name);
    grid_out.write_vtk(mesh_serial, grid_out_file);
    pcout << "  Mesh saved to " << mesh_file_name << std::endl;

    GridTools::partition_triangulation(mpi_size, mesh_serial);
    const auto construction_data = TriangulationDescription::Utilities::
      create_description_from_triangulation(mesh_serial, MPI_COMM_WORLD);
    mesh.create_triangulation(construction_data);

    pcout << "  Number of elements = " << mesh.n_global_active_cells()
          << std::endl;
  }

  pcout << "-----------------------------------------------" << std::endl;

  // Initialize the finite element space.
  {
    pcout << "Initializing the finite element space" << std::endl;

    fe = std::make_unique<FE_Q<dim>>(r);

    pcout << "  Degree                     = " << fe->degree << std::endl;
    pcout << "  DoFs per cell              = " << fe->dofs_per_cell
          << std::endl;

    quadrature = std::make_unique<QGauss<dim>>(r + 1);

    pcout << "  Quadrature points per cell = " << quadrature->size()
          << std::endl;

    // quadrature_boundary = std::make_unique<QGauss<dim - 1>>(r + 1);

    // pcout << "  Quadrature points per boundary cell = "
    //           << quadrature_boundary->size() << std::endl;
  }

  pcout << "-----------------------------------------------" << std::endl;

  // Initialize the DoF handler.
  {
    pcout << "Initializing the DoF handler" << std::endl;

    dof_handler.reinit(mesh);
    dof_handler.distribute_dofs(*fe);

    locally_owned_dofs = dof_handler.locally_owned_dofs();
    DoFTools::extract_locally_relevant_dofs(dof_handler, locally_relevant_dofs);

    pcout << "  Number of DoFs = " << dof_handler.n_dofs() << std::endl;

    // MODIFIED FROM HERE
    // // Count the number of boundary DoFs.
    // dof_handler.n_boundary_dofs();
    // pcout << "  Number of boundary Dofs = " << dof_handler.n_boundary_dofs() << std::endl;

    // // Count the number of internal DoFs that will be Nh.
    // unsigned int n_internal_dofs = dof_handler.n_dofs() - dof_handler.n_boundary_dofs();
    // pcout << "  Number of internal Dofs = " << n_internal_dofs << std::endl;

    // // Try to extract the boundary DoFs.
    // // https://www.dealii.org/current/doxygen/deal.II/namespaceDoFTools.html#a06b3c33925c1a1f15de20deda20b4d21
    // const ComponentMask component_mask = ComponentMask();
    // const std::set<types::boundary_id> boundary_ids = {0, 1, 2, 3}; // #include <set>
    // const IndexSet boundary_dofs = DoFTools::extract_boundary_dofs(dof_handler, component_mask, boundary_ids);
    // std::vector<types::global_dof_index> boundary_dofs_idx;

    // for (auto it = boundary_dofs.begin(); it != boundary_dofs.end(); it++)
    //   boundary_dofs_idx.push_back(*it);

    // pcout << "  Check boundary_dofs_idx.size()    = " << boundary_dofs_idx.size() << std::endl;
    // for (const auto& dof : boundary_dofs_idx)
    //   pcout << "    " << dof << std::endl;
    // pcout << std::endl;

    // boundary_dofs_idx_int.assign(boundary_dofs_idx.begin(), boundary_dofs_idx.end());
    // pcout << "  Check boundary_dofs_idx_int.size() = " << boundary_dofs_idx_int.size() << std::endl;
    // TO HERE
  }

  pcout << "-----------------------------------------------" << std::endl;

  // Initialize the linear system.
  {
    pcout << "Initializing the linear system" << std::endl;

    pcout << "  Initializing the sparsity pattern" << std::endl;

    TrilinosWrappers::SparsityPattern sparsity(locally_owned_dofs,
                                               MPI_COMM_WORLD);
    DoFTools::make_sparsity_pattern(dof_handler, sparsity);
    sparsity.compress();

    // for (unsigned int i = 0; i < modes[0].size(); ++i)
    //   modes_idx.add_index(i);
    // TrilinosWrappers::SparsityPattern sparsity_modes(modes_idx,
    //                                                  MPI_COMM_WORLD);
    // DoFTools::make_sparsity_pattern(dof_handler, sparsity_modes);
    // sparsity_modes.compress();                                                

    pcout << "  Initializing the matrices" << std::endl;
    mass_matrix.reinit(sparsity);
    stiffness_matrix.reinit(sparsity);
    lhs_matrix.reinit(sparsity);
    rhs_matrix.reinit(sparsity);
    // transformation_matrix.reinit(sparsity, sparsity_modes); // qui hai provato perché hai scoperto che definendo numero di elementi non nulli per colonna
    // hai una matrice definita localmente e infatti sembra che tu sia passata ad un nuovo errore
    // snapshot_matrix_trilinos.reinit(sparsity); // prova lo stesso con questo

    // transformation_matrix.reinit(locally_owned_dofs, locally_owned_dofs_r, sparsity, MPI_COMM_WORLD);

    pcout << "  Initializing the system right-hand side" << std::endl;
    system_rhs.reinit(locally_owned_dofs, MPI_COMM_WORLD);
    pcout << "  Initializing the solution vector" << std::endl;
    solution_owned.reinit(locally_owned_dofs, MPI_COMM_WORLD);
    // solution.reinit(locally_owned_dofs, locally_relevant_dofs, MPI_COMM_WORLD);
  }
}

void
AdvDiffPOD::setup_reduced()
{
  // Create the mesh.
  {
    pcout << "Initializing the reduced mesh" << std::endl;

    Triangulation<dim> mesh_serial_r;
    GridGenerator::subdivided_hyper_cube(mesh_serial_r, modes[0].size()-1, 0.0, 1.0, true);
        // QUI HAI CAMBIATO IN MODO CHE LA MATRICE NON ABBIA UN ELEMENTO IN PIU
    pcout << "  Number of elements = " << mesh_r.n_active_cells()
              << std::endl;

    // Write the mesh to file.
    const std::string mesh_file_name_r = "mesh_r-" + std::to_string(modes[0].size()-1) + ".vtk";
    GridOut           grid_out_r;
    std::ofstream     grid_out_file_r(mesh_file_name_r);
    grid_out_r.write_vtk(mesh_serial_r, grid_out_file_r);
    pcout << "  Mesh saved to " << mesh_file_name_r << std::endl;

    GridTools::partition_triangulation(mpi_size, mesh_serial_r);
    const auto construction_data_r = TriangulationDescription::Utilities::
      create_description_from_triangulation(mesh_serial_r, MPI_COMM_WORLD);
    mesh_r.create_triangulation(construction_data_r);

    pcout << "  Number of elements = " << mesh_r.n_global_active_cells()
          << std::endl;
  }

  pcout << "-----------------------------------------------" << std::endl;

  // Initialize the finite element space.
  {
    pcout << "Initializing the finite element space" << std::endl;

    fe_r = std::make_unique<FE_Q<dim>>(r);

    pcout << "  Degree                     = " << fe_r->degree << std::endl;
    pcout << "  DoFs per cell              = " << fe_r->dofs_per_cell
          << std::endl;

    quadrature_r = std::make_unique<QGauss<dim>>(r + 1);

    pcout << "  Quadrature points per cell = " << quadrature_r->size()
          << std::endl;

    // quadrature_boundary = std::make_unique<QGauss<dim - 1>>(r + 1);

    // pcout << "  Quadrature points per boundary cell = "
    //           << quadrature_boundary->size() << std::endl;
  }

  pcout << "-----------------------------------------------" << std::endl;

  // Initialize the DoF handler.
  {
    pcout << "Initializing the DoF handler" << std::endl;

    dof_handler_r.reinit(mesh_r);
    dof_handler_r.distribute_dofs(*fe_r);

    locally_owned_dofs_r = dof_handler_r.locally_owned_dofs();
    DoFTools::extract_locally_relevant_dofs(dof_handler_r, locally_relevant_dofs_r);

    pcout << "  Number of DoFs = " << dof_handler_r.n_dofs() << std::endl;

    // MODIFIED FROM HERE
    // // Count the number of boundary DoFs.
    // dof_handler.n_boundary_dofs();
    // pcout << "  Number of boundary Dofs = " << dof_handler.n_boundary_dofs() << std::endl;

    // // Count the number of internal DoFs that will be Nh.
    // unsigned int n_internal_dofs = dof_handler.n_dofs() - dof_handler.n_boundary_dofs();
    // pcout << "  Number of internal Dofs = " << n_internal_dofs << std::endl;

    // // Try to extract the boundary DoFs.
    // // https://www.dealii.org/current/doxygen/deal.II/namespaceDoFTools.html#a06b3c33925c1a1f15de20deda20b4d21
    // const ComponentMask component_mask = ComponentMask();
    // const std::set<types::boundary_id> boundary_ids = {0, 1, 2, 3}; // #include <set>
    // const IndexSet boundary_dofs = DoFTools::extract_boundary_dofs(dof_handler, component_mask, boundary_ids);
    // std::vector<types::global_dof_index> boundary_dofs_idx;

    // for (auto it = boundary_dofs.begin(); it != boundary_dofs.end(); it++)
    //   boundary_dofs_idx.push_back(*it);

    // pcout << "  Check boundary_dofs_idx.size()    = " << boundary_dofs_idx.size() << std::endl;
    // for (const auto& dof : boundary_dofs_idx)
    //   pcout << "    " << dof << std::endl;
    // pcout << std::endl;

    // boundary_dofs_idx_int.assign(boundary_dofs_idx.begin(), boundary_dofs_idx.end());
    // pcout << "  Check boundary_dofs_idx_int.size() = " << boundary_dofs_idx_int.size() << std::endl;
    // TO HERE
  }

  pcout << "-----------------------------------------------" << std::endl;

  // Initialize the linear system.
  {
    pcout << "Initializing the linear system" << std::endl;

    pcout << "  Initializing the sparsity pattern" << std::endl;

    TrilinosWrappers::SparsityPattern sparsity_r(locally_owned_dofs_r,
                                                 MPI_COMM_WORLD);
    DoFTools::make_sparsity_pattern(dof_handler_r, sparsity_r);
    sparsity_r.compress();

    pcout << "  Initializing the matrices" << std::endl;
    // mass_matrix.reinit(sparsity_r);
    // stiffness_matrix.reinit(sparsity_r);
    reduced_system_lhs.reinit(sparsity_r); // prova ad aggiungere questo per risolvere il problema di mpi
    // rhs_matrix.reinit(sparsity_r);

    pcout << "  Initializing the system right-hand side" << std::endl;
    reduced_system_rhs.reinit(locally_owned_dofs_r, MPI_COMM_WORLD); // SCOMMENTANDO QUESTO IL CODICE FUNZIONA SENZA MPI
    pcout << "  Initializing the solution vector" << std::endl;
    reduced_solution_owned.reinit(locally_owned_dofs_r, MPI_COMM_WORLD);
    reduced_solution.reinit(locally_owned_dofs_r, locally_relevant_dofs_r, MPI_COMM_WORLD);
  }
}

void
AdvDiffPOD::assemble_matrices()
{
  pcout << "===============================================" << std::endl;
  pcout << "Assembling the system matrices" << std::endl;

  const unsigned int dofs_per_cell = fe->dofs_per_cell;
  const unsigned int n_q           = quadrature->size();

  FEValues<dim> fe_values(*fe,
                          *quadrature,
                          update_values | update_gradients |
                            update_quadrature_points | update_JxW_values);

  // FEFaceValues<dim> fe_values_boundary(*fe,
  //                                      *quadrature_boundary,
  //                                      update_values |
  //                                        update_quadrature_points |
  //                                        update_JxW_values);

  FullMatrix<double> cell_mass_matrix(dofs_per_cell, dofs_per_cell);
  FullMatrix<double> cell_stiffness_matrix(dofs_per_cell, dofs_per_cell);

  std::vector<types::global_dof_index> dof_indices(dofs_per_cell);

  mass_matrix      = 0.0;
  stiffness_matrix = 0.0;

  for (const auto &cell : dof_handler.active_cell_iterators())
    {
      if (!cell->is_locally_owned())
        continue;

      fe_values.reinit(cell);

      cell_mass_matrix      = 0.0;
      cell_stiffness_matrix = 0.0;

      for (unsigned int q = 0; q < n_q; ++q)
        {
          // Evaluate coefficients on this quadrature node.
          const double mu_loc   = mu.value(fe_values.quadrature_point(q));

          // Evaluate the transport term on this quadrature node.
          Vector<double> beta_vector(dim);
          beta.vector_value(fe_values.quadrature_point(q), beta_vector);

          // Convert the transport term to a tensor (so that we can use it with
          // scalar_product).
          Tensor<1, dim> beta_tensor;
          for (unsigned int i = 0; i < dim; ++i)
            beta_tensor[i] = beta_vector[i];
          
          for (unsigned int i = 0; i < dofs_per_cell; ++i)
            {
              for (unsigned int j = 0; j < dofs_per_cell; ++j)
                {
                  cell_mass_matrix(i, j) += fe_values.shape_value(i, q) *
                                            fe_values.shape_value(j, q) /
                                            deltat * fe_values.JxW(q);

                  cell_stiffness_matrix(i, j) +=
                    mu_loc * fe_values.shape_grad(i, q) *
                    fe_values.shape_grad(j, q) * fe_values.JxW(q);

                  // Transport term.
                  cell_stiffness_matrix(i, j) += 
                    scalar_product(beta_tensor, fe_values.shape_grad(j, q)) *
                    fe_values.shape_value(i, q) * fe_values.JxW(q);
                    
                }
            }
        }

      cell->get_dof_indices(dof_indices);

      mass_matrix.add(dof_indices, cell_mass_matrix);
      stiffness_matrix.add(dof_indices, cell_stiffness_matrix);
    }

  mass_matrix.compress(VectorOperation::add);
  stiffness_matrix.compress(VectorOperation::add);

  // We build the matrix on the left-hand side of the algebraic problem (the one
  // that we'll invert at each timestep).
  lhs_matrix.copy_from(mass_matrix);
  lhs_matrix.add(theta, stiffness_matrix);

  // We build the matrix on the right-hand side (the one that multiplies the old
  // solution un).
  rhs_matrix.copy_from(mass_matrix);
  rhs_matrix.add(-(1.0 - theta), stiffness_matrix);
}

void
AdvDiffPOD::assemble_rhs(const double &time, TrilinosWrappers::SparseMatrix &snapshot_matrix_trilinos)
{
  const unsigned int dofs_per_cell = fe->dofs_per_cell;
  const unsigned int n_q           = quadrature->size();

  FEValues<dim> fe_values(*fe,
                          *quadrature,
                          update_values | update_quadrature_points |
                            update_JxW_values);

  Vector<double> cell_rhs(dofs_per_cell);

  std::vector<types::global_dof_index> dof_indices(dofs_per_cell);

  system_rhs = 0.0;

  for (const auto &cell : dof_handler.active_cell_iterators())
    {
      if (!cell->is_locally_owned())
        continue;

      fe_values.reinit(cell);

      cell_rhs = 0.0;

      for (unsigned int q = 0; q < n_q; ++q)
        {
          // We need to compute the forcing term at the current time (tn+1) and
          // at the old time (tn). deal.II Functions can be computed at a
          // specific time by calling their set_time method.

          // Compute f(tn+1)
          forcing_term.set_time(time);
          const double f_new_loc =
            forcing_term.value(fe_values.quadrature_point(q));

          // Compute f(tn)
          forcing_term.set_time(time - deltat);
          const double f_old_loc =
            forcing_term.value(fe_values.quadrature_point(q));

          for (unsigned int i = 0; i < dofs_per_cell; ++i)
            {
              cell_rhs(i) += (theta * f_new_loc + (1.0 - theta) * f_old_loc) *
                             fe_values.shape_value(i, q) * fe_values.JxW(q);
            }
        }

      cell->get_dof_indices(dof_indices);
      system_rhs.add(dof_indices, cell_rhs);
    }

  system_rhs.compress(VectorOperation::add);

  // Add the term that comes from the old solution.
  TrilinosWrappers::MPI::Vector aux(locally_owned_dofs, MPI_COMM_WORLD);
  // pcout << "  Check aux.size() = " << aux.size() << std::endl;
  // pcout << "  Check solution_owned.size() = " << solution_owned.size() << std::endl;
  // DA CORREGGERE
  for (unsigned int i = 0; i < aux.size(); ++i)
    // aux.add(i, snapshot_matrix[i][(time-deltat)/deltat]);
    aux(i) = snapshot_matrix_trilinos(i, (time-deltat)/deltat);
  aux.compress(VectorOperation::add);
  pcout << "BLOCCO QUI" << std::endl;

  rhs_matrix.vmult_add(system_rhs, aux); // QUI TI SERVIREBBE NUOVA SOLUTION
  
  // Boundary conditions.
  {
    std::map<types::global_dof_index, double> boundary_values;

    std::map<types::boundary_id, const Function<dim> *> boundary_functions;

    boundary_functions[0] = &function_g;
    boundary_functions[1] = &function_g;

    VectorTools::interpolate_boundary_values(dof_handler,
                                             boundary_functions,
                                             boundary_values);

    MatrixTools::apply_boundary_values(
      boundary_values, lhs_matrix, solution_owned, system_rhs, false);
  }
}

void
AdvDiffPOD::assemble_reduced_rhs(const double &time)
{
  const unsigned int dofs_per_cell_r = fe_r->dofs_per_cell;
  const unsigned int n_q_r           = quadrature_r->size();

  FEValues<dim> fe_values_r(*fe_r,
                            *quadrature_r,
                            update_values | update_quadrature_points |
                            update_JxW_values);

  Vector<double> cell_rhs_r(dofs_per_cell_r);

  std::vector<types::global_dof_index> dof_indices_r(dofs_per_cell_r);

  reduced_system_rhs = 0.0;

  for (const auto &cell : dof_handler_r.active_cell_iterators())
    {
      if (!cell->is_locally_owned())
        continue;

      fe_values_r.reinit(cell);

      cell_rhs_r = 0.0;

      for (unsigned int q = 0; q < n_q_r; ++q)
        {
          // We need to compute the forcing term at the current time (tn+1) and
          // at the old time (tn). deal.II Functions can be computed at a
          // specific time by calling their set_time method.

          // Compute f(tn+1)
          forcing_term.set_time(time);
          const double f_new_loc =
            forcing_term.value(fe_values_r.quadrature_point(q));

          // Compute f(tn)
          forcing_term.set_time(time - deltat);
          const double f_old_loc =
            forcing_term.value(fe_values_r.quadrature_point(q));

          for (unsigned int i = 0; i < dofs_per_cell_r; ++i)
            {
              cell_rhs_r(i) += (theta * f_new_loc + (1.0 - theta) * f_old_loc) *
                               fe_values_r.shape_value(i, q) * fe_values_r.JxW(q);
            }
        }

      cell->get_dof_indices(dof_indices_r);
      reduced_system_rhs.add(dof_indices_r, cell_rhs_r);
    }

  reduced_system_rhs.compress(VectorOperation::add);

  // Add the term that comes from the old solution.
  reduced_rhs_matrix.vmult_add(reduced_system_rhs, reduced_solution_owned); // QUI TI SERVIREBBE NUOVA SOLUTION
  
  // Boundary conditions.
  {
    std::map<types::global_dof_index, double> boundary_values;

    std::map<types::boundary_id, const Function<dim> *> boundary_functions;

    boundary_functions[0] = &function_g;
    boundary_functions[1] = &function_g;

    VectorTools::interpolate_boundary_values(dof_handler_r,
                                             boundary_functions,
                                             boundary_values);

    MatrixTools::apply_boundary_values(
      boundary_values, reduced_system_lhs, reduced_solution_owned, reduced_system_rhs, false);
  }
}

// // COMMENTA PROIEZIONE
// void
// AdvDiffPOD::convert_modes(FullMatrix<double> &transformation_matrix)
// {
//   // transformation_matrix.copy_from(modes);
//   // transformation_matrix.reinit(modes.size(), modes[0].size());
//   // transformation_matrix.m() = modes.size();
//   // transformation_matrix.n() = modes[0].size();
//   // TrilinosWrappers::SparseMatrix transformation_matrix(modes.size(), modes[0].size());
//   // TrilinosWrappers::SparseMatrix transformation_matrix(static_cast<unsigned int>(modes.size()), 
//   //                                                      static_cast<unsigned int>(modes[0].size()));
//   for (unsigned int i = 0; i < modes.size(); ++i)
//     for (unsigned int j = 0; j < modes[0].size(); ++j)
//   //     // transformation_matrix.set(i, j, modes[i][j]);
//       transformation_matrix(i, j) = modes[i][j];
//   // transformation_matrix.copy_from(modes); // vedi se l'errore di .m e .n è qui e mi sa che era qui ...

//   pcout << "  Check transformation_matrix: " << std::endl;
//   pcout << modes[0][0] << std::endl;
//   pcout << transformation_matrix(0, 0) << std::endl;
//   pcout << modes[1][0] << std::endl;
//   pcout << transformation_matrix(1, 0) << std::endl;
//   pcout << modes[1][1] << std::endl;
//   pcout << transformation_matrix(1, 1) << std::endl;
//   pcout << modes[1][40] << std::endl;
//   pcout << transformation_matrix(1, 40) << std::endl;
//   pcout << "  Check transformation_matrix: size" << std::endl;
//   pcout << modes.size() << std::endl;
//   pcout << transformation_matrix.m() << std::endl;
//   pcout << modes[0].size() << std::endl;
//   pcout << transformation_matrix.n() << std::endl;
// }

// void
// AdvDiffPOD::project_u0(FullMatrix<double> &transformation_matrix)
// {
//   // QUI MI SA PROBLEMA CHE u_0 non è vettore ma funzione
//   // reduced_u_0.Tvmult(transformation_matrix, u_0);
//   // reduced_u_0 = transformation_matrixT * u_0;

//   Vector<double> dst(solution_owned.size());
//   Vector<double> solution_owned_copy(solution_owned.size());
//   for(unsigned int i = 0; i < solution_owned.size(); ++i)
//     solution_owned_copy(i) = solution_owned(i);
//   // solution_owned_copy.copy_from(solution_owned);
// //   std::vector<Point<dim>> &points;


// // // template <int dim>
// // // void function_to_vector(const Function<dim> &function, Vector<double> &vector, const std::vector<Point<dim>> &points)
// // Point<dim> & p
// // // {
// // //   const unsigned int n_points = points.size();
// // //   vector.reinit(n_points);

// // //   for (unsigned int i = 0; i < n_points; ++i)
// // //   {
// // //     vector[i] = function.value(points[i]);
// // //   }
// // // }


//   // Matrix-vector multiplication: let dst = MT*src with M being this matrix. This function does the same as vmult() but takes
//   // the transposed matrix.
//   // aux.reinit(solution_owned.size());
//   // aux.reinit(solution_owned); // DIMENSIONE

//   transformation_matrix.Tvmult(dst, solution_owned_copy);
//   // solution_owned.reinit(dst);
//   for (unsigned int i = 0; i < dst.size(); ++i)
//     solution_owned(i) = dst(i);
//   // solution_owned.set(); // MAGARI PER AVERE MENO CONFLITTI DATO CHE NON SO COME VIENE FATTA OPERAZIONE
//   // solution_owned.Tvmult(transformation_matrix, solution_owned);
// }

// void
// AdvDiffPOD::project_lhs(FullMatrix<double> &transformation_matrix)
// {
//   // TrilinosWrappers::SparseMatrix aux(static_cast<unsigned int>(lhs_matrix.m()), static_cast<unsigned int>(lhs_matrix.n())); // ANCHE QUI SERVE DIMENSIONE?
//   // aux.Tmmult(transformation_matrix, lhs_matrix);
//   // reduced_system_lhs.mmult(aux, transformation_matrix);
//   // ATTENZIONE SISTEMA CAPENDO INPUT E OUTPUT
//   // aux.reinit(lhs_matrix.size());
//   FullMatrix<double> aux(transformation_matrix.n(), lhs_matrix.n()); // (Tn * Tm) * (Lm * Ln) = Tn * Ln
//   FullMatrix<double> dst(transformation_matrix.n(), transformation_matrix.n()); // (Tn * Ln) * (Tm * Tn) = Tn * Tn
//   FullMatrix<double> lhs_matrix_copy(lhs_matrix.m(), lhs_matrix.n());
//   for (unsigned int i = 0; i < lhs_matrix.m(); ++i)
//     for (unsigned int j = 0; j < lhs_matrix.n(); ++j)
//       lhs_matrix_copy(i, j) = lhs_matrix(i, j);
//   // lhs_matrix_copy.copy_from(lhs_matrix); // non mi sembra funzionare

//   pcout << "  Check lhs_matrix_copy: " << std::endl;
//   pcout << lhs_matrix(0, 0) << std::endl;
//   pcout << lhs_matrix_copy(0, 0) << std::endl;
//   pcout << lhs_matrix(1, 0) << std::endl;
//   pcout << lhs_matrix_copy(1, 0) << std::endl;

//   transformation_matrix.Tmmult(aux, lhs_matrix_copy);
//   aux.mmult(dst, transformation_matrix);





//   // PROVA A COMPORRE VETTORE PER VETTORE
//   // std::vector<size_t> indexes(transformation_matrix.n());
//   // for (size_t i = 0; i < transformation_matrix.n(); i++)
//   //   indexes.push_back(i);


//   // TrilinosWrappers::MPI::Vector aux_vec(transformation_matrix.n());
//   // for (unsigned int i = 0; i < transformation_matrix.n(); ++i)
//   // {
//   //   for (unsigned int j = 0; j < transformation_matrix.n(); ++j)
//   //   {
//   //     aux_vec(i) = dst(i, j);
//   //   }
//   //   reduced_system_lhs.set(indexes, aux_vec);
//   // }

//   //   reduced_system_lhs.compress(VectorOperation::insert);





//   std::vector<unsigned int> indexes(transformation_matrix.n());
//   for (unsigned int i = 0; i < transformation_matrix.n(); i++)
//     indexes.push_back(i);

//   // std::vector<size_t> indexes(transformation_matrix.n());
//   // for (size_t i = 0; i < transformation_matrix.n(); i++)
//     // indexes.push_back(i);
//   // reduced_system_rhs.set(indexes, indexes, dst);

//   // IndexSet all_indexes(transformation_matrix.n());
//   // for (unsigned int i=0; i<transformation_matrix.n(); ++i)
//   //   all_indexes.add_index(i);
//   // TrilinosWrappers::SparsityPattern all(all_indexes, MPI_COMM_WORLD);
//   // all.compress();
//   // reduced_system_lhs.reinit(all);
//   // reduced_system_lhs.set(all_indexes, dst);
//   // reduced_system_lhs.compress(VectorOperation::add); // prova a vedere se codì non escono gli zeri
// // .......
//   //   std::vector<unsigned int> row_indices;
//   //   std::vector<unsigned int> col_indices;
//   //   std::vector<double> values;

//   //     for (unsigned int i = 0; i < transformation_matrix.n(); ++i)
//   //   {
//   //       for (unsigned int j = 0; j < transformation_matrix.n(); ++j)
//   //       {
//   //           if (dst(i, j) != 0.0)
//   //           {
//   //               row_indices.push_back(i);
//   //               col_indices.push_back(j);
//   //               values.push_back(dst(i, j));
//   //           }
//   //       }
//   //   }

//   //   // Set values in reduced_system_lhs
//   //   reduced_system_lhs.set(row_indices, col_indices, values);

//   //   // Compress to finalize the matrix assembly
//   //   reduced_system_lhs.compress(VectorOperation::insert);
// // :::::::::::::::

//   // for (unsigned int i = 0; i < transformation_matrix.n(); i++)
//   //   for (unsigned int j = 0; j < transformation_matrix.n(); j++)
//   //   {
//   //     double aux = dst(i, j);
//   //     reduced_system_lhs.add(i, j, aux); // MI SA CHE STO COSO NON FUNZIONA PERCHÉ STAMPANDO ESCONO ZERI
//   //     // prova con add perché tanto matrice inizializzata a zero
//   //     // reduced_system_lhs(i, j) = dst(i, j);
//   //   }
//     // reduced_system_lhs.add(indexes, dst);

//     reduced_system_lhs.compress(VectorOperation::add); // prova a vedere se codì non escono gli zeri
//         reduced_system_lhs.add(indexes, dst);


  
//     pcout << "  Check reduced_system_lhs: " << std::endl;
//   pcout << dst(0, 0) << std::endl;
//   pcout << reduced_system_lhs(0, 0) << std::endl;
//   pcout << dst(1, 0) << std::endl;
//   pcout << reduced_system_lhs(1, 0) << std::endl;


//   // check dim
//   // if
//   // MPI_ABORT(MPI_COMM_WORLD, 1);
// }

// void
// AdvDiffPOD::project_rhs(FullMatrix<double> &transformation_matrix)
// {
//   // reduced_system_rhs.Tvmult(transformation_matrix, system_rhs);
//   Vector<double> dst(transformation_matrix.n());
//   Vector<double> system_rhs_copy(transformation_matrix.m());

//   // FAI CHECK SU DIMENSIONI CON ERRORE
//   for (unsigned int i = 0; i < transformation_matrix.m(); ++i)
//     system_rhs_copy(i) = system_rhs(i);

//     pcout << "  Check rhs_matrix_copy: " << std::endl;
//   pcout << system_rhs(40) << std::endl;
//   pcout << system_rhs_copy(40) << std::endl;
//   pcout << system_rhs(41) << std::endl;
//   pcout << system_rhs_copy(41) << std::endl;

//   transformation_matrix.Tvmult(dst, system_rhs_copy);
//   // reduced_system_rhs.reinit(dst);
//   for (unsigned int i = 0; i < transformation_matrix.n(); ++i)
//     reduced_system_rhs(i) = dst(i); // RICERCATI POI DEFINIZIONE DELLE VARIE FUNZIONI PER I VARI OGGETTI

//       pcout << "  Check reduced_system_rhs: " << std::endl;
//   pcout << dst(40) << std::endl;
//   pcout << reduced_system_rhs(40) << std::endl;
//   pcout << dst(41) << std::endl;
//   pcout << reduced_system_rhs(41) << std::endl;
// }

// COMMENTA PROIEZIONE
void
AdvDiffPOD::convert_modes(TrilinosWrappers::SparseMatrix &transformation_matrix)
// AdvDiffPOD::convert_modes(FullMatrix<double> &transformation_matrix)
{
  // transformation_matrix.copy_from(modes);
  // transformation_matrix.reinit(modes.size(), modes[0].size());
  // transformation_matrix.m() = modes.size();
  // transformation_matrix.n() = modes[0].size();
  // TrilinosWrappers::SparseMatrix transformation_matrix(modes.size(), modes[0].size());
  // TrilinosWrappers::SparseMatrix transformation_matrix(static_cast<unsigned int>(modes.size()), 
  //                                                      static_cast<unsigned int>(modes[0].size()));
  for (unsigned int i = 0; i < modes.size(); ++i)
    for (unsigned int j = 0; j < modes[0].size(); ++j)
  //     // transformation_matrix.set(i, j, modes[i][j]);
      // transformation_matrix(i, j) = modes[i][j];
      transformation_matrix.set(i, j, modes[i][j]);
  transformation_matrix.compress(VectorOperation::add);
  // transformation_matrix.copy_from(modes); // vedi se l'errore di .m e .n è qui e mi sa che era qui ...

  pcout << "  Check transformation_matrix: " << std::endl;
  pcout << modes[0][0] << std::endl;
  pcout << transformation_matrix(0, 0) << std::endl;
  pcout << modes[1][0] << std::endl;
  pcout << transformation_matrix(1, 0) << std::endl;
  pcout << modes[1][1] << std::endl;
  pcout << transformation_matrix(1, 1) << std::endl;
  pcout << modes[40][1] << std::endl;
  pcout << transformation_matrix(40, 1) << std::endl;
  pcout << modes[44][1] << std::endl;
  pcout << transformation_matrix(44, 1) << std::endl;
  pcout << modes[89][1] << std::endl;
  pcout << transformation_matrix(89, 1) << std::endl;
  pcout << modes[108][1] << std::endl;
  pcout << transformation_matrix(108, 1) << std::endl;
  pcout << modes[27][0] << std::endl;
  pcout << transformation_matrix(27, 0) << std::endl;
  pcout << "  Check transformation_matrix: size" << std::endl;
  pcout << modes.size() << std::endl;
  pcout << transformation_matrix.m() << std::endl;
  pcout << modes[0].size() << std::endl;
  pcout << transformation_matrix.n() << std::endl;
}

void
AdvDiffPOD::project_u0(TrilinosWrappers::SparseMatrix &transformation_matrix)
// AdvDiffPOD::project_u0(FullMatrix<double> &transformation_matrix)
{
  // QUI MI SA PROBLEMA CHE u_0 non è vettore ma funzione
  // reduced_u_0.Tvmult(transformation_matrix, u_0);
  // reduced_u_0 = transformation_matrixT * u_0;

  // Vector<double> dst(solution_owned.size());
  // Vector<double> solution_owned_copy(solution_owned.size());
  // for(unsigned int i = 0; i < solution_owned.size(); ++i)
  //   solution_owned_copy(i) = solution_owned(i);
  // solution_owned_copy.copy_from(solution_owned);
//   std::vector<Point<dim>> &points;


// // template <int dim>
// // void function_to_vector(const Function<dim> &function, Vector<double> &vector, const std::vector<Point<dim>> &points)
// Point<dim> & p
// // {
// //   const unsigned int n_points = points.size();
// //   vector.reinit(n_points);

// //   for (unsigned int i = 0; i < n_points; ++i)
// //   {
// //     vector[i] = function.value(points[i]);
// //   }
// // }


  // Matrix-vector multiplication: let dst = MT*src with M being this matrix. This function does the same as vmult() but takes
  // the transposed matrix.
  // aux.reinit(solution_owned.size());
  // aux.reinit(solution_owned); // DIMENSIONE

  // TrilinosWrappers::MPI::Vector dst;
  reduced_solution_owned = 0.0;
  transformation_matrix.Tvmult(reduced_solution_owned, solution_owned);
  reduced_solution_owned.compress(VectorOperation::add);
  // solution_owned.reinit(dst);
  // for (unsigned int i = 0; i < dst.size(); ++i)
  //   solution_owned(i) = dst(i);
  // solution_owned.set(); // MAGARI PER AVERE MENO CONFLITTI DATO CHE NON SO COME VIENE FATTA OPERAZIONE
  // solution_owned.Tvmult(transformation_matrix, solution_owned);
}

void
AdvDiffPOD::project_lhs(TrilinosWrappers::SparseMatrix &transformation_matrix)
// AdvDiffPOD::project_lhs(FullMatrix<double> &transformation_matrix)
{
  // TrilinosWrappers::SparseMatrix aux(static_cast<unsigned int>(lhs_matrix.m()), static_cast<unsigned int>(lhs_matrix.n())); // ANCHE QUI SERVE DIMENSIONE?
  // aux.Tmmult(transformation_matrix, lhs_matrix);
  // reduced_system_lhs.mmult(aux, transformation_matrix);
  // ATTENZIONE SISTEMA CAPENDO INPUT E OUTPUT
  // aux.reinit(lhs_matrix.size());

  ////////////////////////
  // FullMatrix<double> aux(transformation_matrix.n(), lhs_matrix.n()); // (Tn * Tm) * (Lm * Ln) = Tn * Ln
  // FullMatrix<double> dst(transformation_matrix.n(), transformation_matrix.n()); // (Tn * Ln) * (Tm * Tn) = Tn * Tn
  // FullMatrix<double> lhs_matrix_copy(lhs_matrix.m(), lhs_matrix.n());
  // for (unsigned int i = 0; i < lhs_matrix.m(); ++i)
  //   for (unsigned int j = 0; j < lhs_matrix.n(); ++j)
  //     // lhs_matrix_copy(i, j) = lhs_matrix(i, j);
  //     lhs_matrix_copy.set(i, j, lhs_matrix(i, j));
  // // lhs_matrix_copy.copy_from(lhs_matrix); // non mi sembra funzionare

  // pcout << "  Check lhs_matrix_copy: " << std::endl;
  // pcout << lhs_matrix(0, 0) << std::endl;
  // pcout << lhs_matrix_copy(0, 0) << std::endl;
  // pcout << lhs_matrix(1, 0) << std::endl;
  // pcout << lhs_matrix_copy(1, 0) << std::endl;

  // pcout << "BLOCCO QUI 1" << std::endl;
  // // reduced_system_lhs = 0.0;
  // assert(transformation_matrix.m() == lhs_matrix_copy.m()); // controllo
  // pcout << "Check lhs size" << lhs_matrix_copy.m() << "*" << lhs_matrix_copy.n() << std::endl;
  // transformation_matrix.Tmmult(aux, lhs_matrix_copy);
  // pcout << "Check aux size" << aux.m() << "*" << aux.n() << std::endl;
  // pcout << "check aux 1, 1" << aux(1, 1) << std::endl;
  // pcout << "BLOCCO QUI 2" << std::endl;
  // assert(aux.n() == transformation_matrix.m());
  // aux.mmult(dst, transformation_matrix);
  // pcout << "Check res size" << dst.m() << "*" << dst.n() << std::endl;
  // // aux.mmult(reduced_system_lhs, transformation_matrix);
  // pcout << "BLOCCO QUI 3" << std::endl;
  // for (unsigned int i = 0; i < transformation_matrix.n(); ++i)
  //   for (unsigned int j = 0; j < transformation_matrix.n(); ++j)
  //     reduced_system_lhs.set(i, j, dst(i, j));
  // // reduced_system_lhs.copy_from(); // eventualmente togliere
  // reduced_system_lhs.compress(VectorOperation::add);
  // pcout << "BLOCCO QUI 4" << std::endl;
////////////////


  TrilinosWrappers::SparseMatrix aux; // (locally_owned_dofs, MPI_COMM_WORLD); // (locally_owned_dofs, MPI_COMM_WORLD); // AGGIUNTO Locally owned
  TrilinosWrappers::SparseMatrix res;
  // // TrilinosWrappers::SparseMatrix aux(transformation_matrix.n(), lhs_matrix.n(), lhs_matrix.n());
  // // TrilinosWrappers::SparseMatrix res(transformation_matrix.n(), transformation_matrix.n(), transformation_matrix.n());

  pcout << "BLOCCO QUI 1" << std::endl;
  reduced_system_lhs = 0.0;
  assert(transformation_matrix.m() == lhs_matrix.m()); // controllo
  pcout << "Check lhs size" << lhs_matrix.m() << "*" << lhs_matrix.n() << std::endl;
  transformation_matrix.Tmmult(aux, lhs_matrix);
  pcout << "Check aux size" << aux.m() << "*" << aux.n() << std::endl;
  pcout << "check aux 1, 1" << aux(1, 1) << std::endl;
  pcout << "BLOCCO QUI 2" << std::endl;
  assert(aux.n() == transformation_matrix.m());
  aux.mmult(res, transformation_matrix);
  pcout << "Check res size" << res.m() << "*" << res.n() << std::endl;
  // aux.mmult(reduced_system_lhs, transformation_matrix);
  pcout << "BLOCCO QUI 3" << std::endl;
  // for (unsigned int i = 0; i < transformation_matrix.n(); ++i)
  //   for (unsigned int j = 0; j < transformation_matrix.n(); ++j)
  //     reduced_system_lhs.set(i, j, res(i, j));
  reduced_system_lhs.copy_from(res); // eventualmente togliere
  reduced_system_lhs.compress(VectorOperation::add);
  pcout << "BLOCCO QUI 4" << std::endl;
 // ------------------------file vecchio
  //   TrilinosWrappers::SparseMatrix aux(locally_owned_dofs, MPI_COMM_WORLD); // AGGIUNTO Locally owned
  // reduced_system_lhs = 0.0;
  // transformation_matrix.Tmmult(aux, lhs_matrix);
  // aux.mmult(reduced_system_lhs, transformation_matrix);
  // reduced_system_lhs.compress(VectorOperation::add);


  //////////////////
  // MPIGather qui?
  // MPI_Gather(&transformation_matrix, transformation_matrix.local_size(), MPI_UNSIGNED_LONG, 
  //            &transformation_matrix, transformation_matrix.local_size(), MPI_UNSIGNED_LONG, 0, MPI_COMM_WORLD);
  // std::vector<unsigned int> all_sizes(mpi_size);
  // MPI_Gather(&transformation_matrix.local_size(), 1, MPI_UNSIGNED, all_sizes.data(), 1, MPI_UNSIGNED, 0, MPI_COMM_WORLD);
  // if (mpi_rank == 0)
  // {
  //   TrilinosWrappers::SparseMatrix t_copy(transformation_matrix.m(), transformation_matrix.n(), transformation_matrix.n()); // prova a copiare
  //   TrilinosWrappers::SparseMatrix lhs_copy(lhs_matrix.m(), lhs_matrix.n(), lhs_matrix.n()); // così dovrebbero essere locali
  //   TrilinosWrappers::SparseMatrix aux(transformation_matrix.n(), lhs_matrix.n(), lhs_matrix.n()); // così dovrebbero essere locali
  //   TrilinosWrappers::SparseMatrix res(transformation_matrix.n(), transformation_matrix.n(), transformation_matrix.n());
  //   for (unsigned int i=0; i<transformation_matrix.m(); i++)
  //     for (unsigned int j=0; j<transformation_matrix.m(); j++)
  //       t_copy.set(i, j, transformation_matrix(i, j));
  //   t_copy.compress(VectorOperation::add);
  //   for (unsigned int i=0; i<lhs_matrix.m(); i++)
  //     for (unsigned int j=0; i<lhs_matrix.m(); j++)
  //       lhs_copy.set(i, j, lhs_matrix(i, j));
  //   lhs_copy.compress(VectorOperation::add);
  //   pcout << "BLOCCO QUI 1" << std::endl;
  //   // t_copy.compress(VectorOperation::add);
  //   t_copy.Tmmult(aux, lhs_matrix);
  //   pcout << "BLOCCO QUI 2" << std::endl;
  //   aux.mmult(reduced_system_lhs, t_copy);
  //   pcout << "BLOCCO QUI 3" << std::endl;
  //   reduced_system_lhs.compress(VectorOperation::add);
  //   pcout << "BLOCCO QUI 4" << std::endl;
  // }


  // PROVA A COMPORRE VETTORE PER VETTORE
  // std::vector<size_t> indexes(transformation_matrix.n());
  // for (size_t i = 0; i < transformation_matrix.n(); i++)
  //   indexes.push_back(i);


  // TrilinosWrappers::MPI::Vector aux_vec(transformation_matrix.n());
  // for (unsigned int i = 0; i < transformation_matrix.n(); ++i)
  // {
  //   for (unsigned int j = 0; j < transformation_matrix.n(); ++j)
  //   {
  //     aux_vec(i) = dst(i, j);
  //   }
  //   reduced_system_lhs.set(indexes, aux_vec);
  // }

  //   reduced_system_lhs.compress(VectorOperation::insert);





  // std::vector<unsigned int> indexes(transformation_matrix.n());
  // for (unsigned int i = 0; i < transformation_matrix.n(); i++)
  //   indexes.push_back(i);

  // std::vector<size_t> indexes(transformation_matrix.n());
  // for (size_t i = 0; i < transformation_matrix.n(); i++)
    // indexes.push_back(i);
  // reduced_system_rhs.set(indexes, indexes, dst);

  // IndexSet all_indexes(transformation_matrix.n());
  // for (unsigned int i=0; i<transformation_matrix.n(); ++i)
  //   all_indexes.add_index(i);
  // TrilinosWrappers::SparsityPattern all(all_indexes, MPI_COMM_WORLD);
  // all.compress();
  // reduced_system_lhs.reinit(all);
  // reduced_system_lhs.set(all_indexes, dst);
  // reduced_system_lhs.compress(VectorOperation::add); // prova a vedere se codì non escono gli zeri
// .......
  //   std::vector<unsigned int> row_indices;
  //   std::vector<unsigned int> col_indices;
  //   std::vector<double> values;

  //     for (unsigned int i = 0; i < transformation_matrix.n(); ++i)
  //   {
  //       for (unsigned int j = 0; j < transformation_matrix.n(); ++j)
  //       {
  //           if (dst(i, j) != 0.0)
  //           {
  //               row_indices.push_back(i);
  //               col_indices.push_back(j);
  //               values.push_back(dst(i, j));
  //           }
  //       }
  //   }

  //   // Set values in reduced_system_lhs
  //   reduced_system_lhs.set(row_indices, col_indices, values);

  //   // Compress to finalize the matrix assembly
  //   reduced_system_lhs.compress(VectorOperation::insert);
// :::::::::::::::

  // for (unsigned int i = 0; i < transformation_matrix.n(); i++)
  //   for (unsigned int j = 0; j < transformation_matrix.n(); j++)
  //   {
  //     double aux = dst(i, j);
  //     reduced_system_lhs.add(i, j, aux); // MI SA CHE STO COSO NON FUNZIONA PERCHÉ STAMPANDO ESCONO ZERI
  //     // prova con add perché tanto matrice inizializzata a zero
  //     // reduced_system_lhs(i, j) = dst(i, j);
  //   }
    // reduced_system_lhs.add(indexes, dst);

    // reduced_system_lhs.compress(VectorOperation::add); // prova a vedere se codì non escono gli zeri
    //     reduced_system_lhs.add(indexes, dst);


  
  pcout << "  Check reduced_system_lhs: " << std::endl;
  // pcout << dst(0, 0) << std::endl;
  pcout << reduced_system_lhs(0, 0) << std::endl;
  // pcout << dst(1, 0) << std::endl;
  pcout << reduced_system_lhs(1, 0) << std::endl;


  // check dim
  // if
  // MPI_ABORT(MPI_COMM_WORLD, 1);
}

void
AdvDiffPOD::project_rhs(TrilinosWrappers::SparseMatrix &transformation_matrix)
// AdvDiffPOD::project_rhs(FullMatrix<double> &transformation_matrix)
{
  // reduced_system_rhs.Tvmult(transformation_matrix, system_rhs);
  // Vector<double> dst(transformation_matrix.n());
  // Vector<double> system_rhs_copy(transformation_matrix.m());

  // // FAI CHECK SU DIMENSIONI CON ERRORE
  // for (unsigned int i = 0; i < transformation_matrix.m(); ++i)
  //   system_rhs_copy(i) = system_rhs(i);

  //   pcout << "  Check rhs_matrix_copy: " << std::endl;
  // pcout << system_rhs(40) << std::endl;
  // pcout << system_rhs_copy(40) << std::endl;
  // pcout << system_rhs(41) << std::endl;
  // pcout << system_rhs_copy(41) << std::endl;
  // PROBLEMINO QUI
  reduced_system_rhs = 0.0;
  transformation_matrix.Tvmult(reduced_system_rhs, system_rhs);
  reduced_system_rhs.compress(VectorOperation::add);
  // reduced_system_rhs.reinit(dst);
  // for (unsigned int i = 0; i < transformation_matrix.n(); ++i)
  //   reduced_system_rhs(i) = dst(i); // RICERCATI POI DEFINIZIONE DELLE VARIE FUNZIONI PER I VARI OGGETTI

  // pcout << "  Check reduced_system_rhs: " << std::endl;
  // // pcout << dst(40) << std::endl;
  // pcout << reduced_system_rhs(0) << std::endl;
  // // pcout << dst(41) << std::endl;
  // pcout << reduced_system_rhs(1) << std::endl;
}

void
AdvDiffPOD::project_rhs_matrix(TrilinosWrappers::SparseMatrix &transformation_matrix)
// AdvDiffPOD::project_rhs_matrix(FullMatrix<double> &transformation_matrix)
{
  // TrilinosWrappers::SparseMatrix aux(static_cast<unsigned int>(lhs_matrix.m()), static_cast<unsigned int>(lhs_matrix.n())); // ANCHE QUI SERVE DIMENSIONE?
  // aux.Tmmult(transformation_matrix, lhs_matrix);
  // reduced_system_lhs.mmult(aux, transformation_matrix);
  // ATTENZIONE SISTEMA CAPENDO INPUT E OUTPUT
  // aux.reinit(lhs_matrix.size());
  // FullMatrix<double> aux(transformation_matrix.n(), lhs_matrix.n()); // (Tn * Tm) * (Lm * Ln) = Tn * Ln
  // FullMatrix<double> dst(transformation_matrix.n(), transformation_matrix.n()); // (Tn * Ln) * (Tm * Tn) = Tn * Tn
  // FullMatrix<double> lhs_matrix_copy(lhs_matrix.m(), lhs_matrix.n());
  // for (unsigned int i = 0; i < lhs_matrix.m(); ++i)
  //   for (unsigned int j = 0; j < lhs_matrix.n(); ++j)
  //     lhs_matrix_copy(i, j) = lhs_matrix(i, j);
  // lhs_matrix_copy.copy_from(lhs_matrix); // non mi sembra funzionare

  // pcout << "  Check lhs_matrix_copy: " << std::endl;
  // pcout << lhs_matrix(0, 0) << std::endl;
  // pcout << lhs_matrix_copy(0, 0) << std::endl;
  // pcout << lhs_matrix(1, 0) << std::endl;
  // pcout << lhs_matrix_copy(1, 0) << std::endl;

  TrilinosWrappers::SparseMatrix aux;
  reduced_rhs_matrix = 0.0;
  transformation_matrix.Tmmult(aux, rhs_matrix);
  aux.mmult(reduced_rhs_matrix, transformation_matrix);
  reduced_rhs_matrix.compress(VectorOperation::add);


  
  // pcout << "  Check reduced_rhs_matrix: " << std::endl;
  // // pcout << dst(0, 0) << std::endl;
  // pcout << reduced_rhs_matrix(0, 0) << std::endl;
  // // pcout << dst(1, 0) << std::endl;
  // pcout << reduced_rhs_matrix(1, 0) << std::endl;
}



void
AdvDiffPOD::solve_time_step_reduced()
{
  SolverControl solver_control(1000, 1e-6 * reduced_system_rhs.l2_norm());

  SolverCG<TrilinosWrappers::MPI::Vector> solver(solver_control);
  TrilinosWrappers::PreconditionSSOR      preconditioner;
  preconditioner.initialize(
    reduced_system_lhs, TrilinosWrappers::PreconditionSSOR::AdditionalData(1.0));

  solver.solve(reduced_system_lhs, reduced_solution_owned, reduced_system_rhs, preconditioner);
  // pcout << "  " << solver_control.last_step() << " CG iterations" << std::endl;

  reduced_solution = reduced_solution_owned;
}

void
AdvDiffPOD::output(const unsigned int &time_step) const
{
  DataOut<dim> data_out;
  data_out.add_data_vector(dof_handler_r, reduced_solution, "u");

  std::vector<unsigned int> partition_int(mesh_r.n_active_cells());
  GridTools::get_subdomain_association(mesh_r, partition_int);
  const Vector<double> partitioning(partition_int.begin(), partition_int.end());
  data_out.add_data_vector(partitioning, "partitioning");

  data_out.build_patches();

  data_out.write_vtu_with_pvtu_record(
    "./", "output", time_step, MPI_COMM_WORLD, 3);
}

void
AdvDiffPOD::solve_reduced()
{
  assemble_matrices();
  setup_reduced();

  // convertire matrice modes
  // FullMatrix<double> transformation_matrix(modes.size(), modes[0].size());
  // IndexSet locally_modes_rows_id(modes.size()/2);
  // IndexSet locally_modes_cols_id(modes[0].size()/2);
  // for (unsigned int i = 0; i < modes.size(); ++i)
  //   locally_modes_rows_id.add_index(i);
  // for (unsigned int i = 0; i < modes[0].size(); ++i)
  //   locally_modes_cols_id.add_index(i);
  // // TrilinosWrappers::SparseMatrix transformation_matrix(modes.size(), modes[0].size(), modes[0].size());
  // // TrilinosWrappers::SparseMatrix transformation_matrix(modes.size(), modes[0].size(),
  // //                                                      MPI_COMM_WORLD, modes[0].size());
  // TrilinosWrappers::SparseMatrix transformation_matrix(locally_modes_rows_id, locally_modes_cols_id,
  //                                                      MPI_COMM_WORLD);
  // transformation_matrix.compress(VectorOperation::insert);  
// PROBLEMA DIMENSIONI RADDOPPIATE

/*
// C
unsigned int local_num_rows = modes.size() / mpi_size;
unsigned int local_num_cols = modes[0].size() / mpi_size;
unsigned int rows_remainder = modes.size() % mpi_size;
unsigned int cols_remainder = modes[0].size() % mpi_size;

unsigned int row_start = mpi_rank * local_num_rows + std::min(mpi_rank, rows_remainder);
unsigned int row_end = row_start + local_num_rows + (mpi_rank < rows_remainder ? 1 : 0);
unsigned int col_start = mpi_rank * local_num_cols + std::min(mpi_rank, cols_remainder);
unsigned int col_end = col_start + local_num_cols + (mpi_rank < cols_remainder ? 1 : 0);

// IndexSet è sottoinsieme di indici quindi secondo me ha senso cercare di dividerli tra processori
IndexSet locally_owned_modes_rows(local_num_rows); 
IndexSet locally_owned_modes_cols(local_num_cols);

for (unsigned int i = row_start; i < row_end; ++i) // sostituire con add idices
  locally_owned_modes_rows.add_index(i);
// locally_owned_modes_rows.add_indices(row_start, row_end); // ma servono iterators, pensaci dopo
for (unsigned int i = col_start; i < col_end; ++i)
  locally_owned_modes_cols.add_index(i);  
// locally_owned_modes_cols.add_indices(col_start, col_end);
MPI_Barrier(MPI_COMM_WORLD);
TrilinosWrappers::SparseMatrix transformation_matrix(locally_owned_modes_rows, locally_owned_modes_cols,
                                                      MPI_COMM_WORLD);                                           
*/
// if (mpi_rank == 0)
// {
  TrilinosWrappers::SparseMatrix transformation_matrix(modes.size(), modes[0].size(), modes[0].size());
  // FullMatrix<double> transformation_matrix(modes.size(), modes[0].size());
  convert_modes(transformation_matrix);
  try
  {
    // unsigned int *global_rows = nullptr;
    // if (mpi_rank == 0)
    // {
    //   global_rows = new unsigned int[mpi_size];
    // }
    // MPI_Gather(&transformation_matrix, local_num_rows, MPI_DOUBLE, &global_rows, 1, MPI_DOUBLE, 0, MPI_COMM_WORLD);
    // if (mpi_rank == 0)
    // {
      project_lhs(transformation_matrix);
    //   delete[] global_rows;
    // }
  }
  catch (const std::runtime_error &e)
  {
    std::cerr << "Runtime error: " << e.what() << std::endl;
    MPI_Abort(MPI_COMM_WORLD, 1);
  }

  pcout << "  Check lhs:" << reduced_system_lhs.m() << " * " << reduced_system_lhs.n() << std::endl;
  pcout << reduced_system_lhs(0, 0) << std::endl;


  pcout << snapshot_matrix[1][1] << std::endl;

  pcout << "===============================================SEPARA" << std::endl;
  // PROVA, al massimo poi differenzia funzione per non rendere questa troppo lunga
  TrilinosWrappers::SparseMatrix snapshot_matrix_trilinos(snapshot_matrix.size(),
    snapshot_matrix[0].size(), snapshot_matrix[0].size()); // Prova a fare transformation_matrix.reinit(sparsity); anche con questa
  // TrilinosWrappers::SparseMatrix snapshot_matrix_trilinos(snapshot_matrix.size(), snapshot_matrix[0].size(),
  //                                                         MPI_COMM_WORLD, snapshot_matrix[0].size());
  pcout << "===============================================" << std::endl;
  pcout << "Converting the snapshot matrix" << std::endl;

//   const unsigned int dofs_per_cell_s = fe->dofs_per_cell;
//     const unsigned int n_q           = quadrature->size();


//   FullMatrix<double> cell_snapshot_matrix(dofs_per_cell_s, dofs_per_cell_s);

//   std::vector<types::global_dof_index> dof_indices_s(dofs_per_cell_s);

//   snapshot_matrix_trilinos = 0.0;

//   for (const auto &cell : dof_handler.active_cell_iterators())
//     {
//       if (!cell->is_locally_owned())
//         continue;

//       // fe_values.reinit(cell);

//       cell_snapshot_matrix = 0.0;

//       for (unsigned int q = 0; q < n_q; ++q)
//         {
//           for (unsigned int i = 0; i < dofs_per_cell_s; ++i)
//             {
//               for (unsigned int j = 0; j < dofs_per_cell_s; ++j)
//                 {
//                   cell_snapshot_matrix(i, j) = snapshot_matrix[i][j];    
//                 }
//             }
//         }

//       cell->get_dof_indices(dof_indices_s);

//       snapshot_matrix_trilinos.add(dof_indices_s, cell_snapshot_matrix);
//     }

//   snapshot_matrix_trilinos.compress(VectorOperation::add);
// pcout << "FINE PROVA" << std::endl;




  // convert_modes(snapshot_matrix_trilinos); SARÀ CONVERT SNAPSHOTS
  for (unsigned int i = 0; i < snapshot_matrix.size(); ++i)
    for (unsigned int j = 0; j < snapshot_matrix[0].size(); ++j)
  //     // transformation_matrix.set(i, j, modes[i][j]);
      // transformation_matrix(i, j) = modes[i][j];
      snapshot_matrix_trilinos.set(i, j, snapshot_matrix[i][j]);
  snapshot_matrix_trilinos.compress(VectorOperation::add);

  
  pcout << "  Check snapshot_matrix_trilinos: " << std::endl;
  pcout << snapshot_matrix[1][1] << std::endl;
  pcout << snapshot_matrix_trilinos(1, 1) << std::endl;
  pcout << snapshot_matrix[2][1] << std::endl;
  pcout << snapshot_matrix_trilinos(2, 1) << std::endl;







  



  pcout << "===============================================" << std::endl;

  // Apply the initial condition.
  {
    pcout << "Applying the initial condition" << std::endl;

    // project_u0();
    // VectorTools::interpolate(dof_handler_r, u_0, solution_owned); // dato che u_0 è funzione prova a interpolare direttamente, lasciando perdere per un attimo proiezion
    // solution = solution_owned;

    // DOPO PROVA, mi sembra più giusto concettualmente
    VectorTools::interpolate(dof_handler, u_0, solution_owned);
    project_u0(transformation_matrix);
    reduced_solution = reduced_solution_owned;

    // Output the initial solution.
    output(0);
    pcout << "-----------------------------------------------" << std::endl;
  }

  unsigned int time_step = 0;
  double       time      = 0;

  while (time < T)
    {
      time += deltat;
      ++time_step;

      // pcout << "n = " << std::setw(3) << time_step << ", t = " << std::setw(5)
      //       << time << ":" << std::flush;

      // if (time_step == 1)
      // {
      //   assemble_rhs(time);
      //   project_rhs(transformation_matrix);
      //   project_rhs_matrix(transformation_matrix); // per usarla in tutti gli step successivi un po' come lhs
      // }
      // else
      //   assemble_reduced_rhs(time); // Otherwise we would need solution_owned to assemble the reduced system.

      // Prova usando snapshot_matrix come solution_owned full
      // direi ad ogni tempo di prendere solution_owned come snapshot_matrix colonna al tempo precedente
      assemble_rhs(time, snapshot_matrix_trilinos);
      project_rhs(transformation_matrix);

      solve_time_step_reduced();
      output(time_step);
    }

  // RIPROIETTA SU FULL, ma mi sa scritto fuori, in caso aggiungi solution_fom in hpp
  // for (unsigned int i = 0; i < modes.size(); ++i)
  //   for (unsigned int j = 0; j < modes[0].size(); ++j)
  //     solution_fom += modes[i][j] * solution_owned[j];
// } chiude if
}

// double
// AdvDiffPOD::compute_error(const VectorTools::NormType &norm_type)
// {
//   FE_Q<dim> fe_linear(1);
//   MappingFE mapping(fe_linear);

//   const QGauss<dim> quadrature_error = QGauss<dim>(r + 2);

//   exact_solution.set_time(time);

//   Vector<double> error_per_cell;
//   VectorTools::integrate_difference(mapping,
//                                     dof_handler,
//                                     solution,
//                                     exact_solution,
//                                     error_per_cell,
//                                     quadrature_error,
//                                     norm_type);

//   const double error =
//     VectorTools::compute_global_error(mesh, error_per_cell, norm_type);

//   return error;
// }


#include "AdvDiff1D.hpp"

void
AdvDiff::setup()
{
  // Create the mesh.
  {
    pcout << "Initializing the mesh" << std::endl;

    Triangulation<dim> mesh_serial;
    GridGenerator::subdivided_hyper_cube(mesh_serial, N + 1, 0.0, 1.0, true);
    pcout << "  Number of elements = " << mesh.n_active_cells()
              << std::endl;

    // Write the mesh to file.
    const std::string mesh_file_name = "mesh-" + std::to_string(N + 1) + ".vtk";
    GridOut           grid_out;
    std::ofstream     grid_out_file(mesh_file_name);
    grid_out.write_vtk(mesh_serial, grid_out_file);
    pcout << "  Mesh saved to " << mesh_file_name << std::endl;

    GridTools::partition_triangulation(mpi_size, mesh_serial);
    const auto construction_data = TriangulationDescription::Utilities::
      create_description_from_triangulation(mesh_serial, MPI_COMM_WORLD);
    mesh.create_triangulation(construction_data);

    pcout << "  Number of elements = " << mesh.n_global_active_cells()
          << std::endl;
  }

  pcout << "-----------------------------------------------" << std::endl;

  // Initialize the finite element space.
  {
    pcout << "Initializing the finite element space" << std::endl;

    fe = std::make_unique<FE_Q<dim>>(r);

    pcout << "  Degree                     = " << fe->degree << std::endl;
    pcout << "  DoFs per cell              = " << fe->dofs_per_cell
          << std::endl;

    quadrature = std::make_unique<QGauss<dim>>(r + 1);

    pcout << "  Quadrature points per cell = " << quadrature->size()
          << std::endl;

    // quadrature_boundary = std::make_unique<QGauss<dim - 1>>(r + 1);

    // pcout << "  Quadrature points per boundary cell = "
    //           << quadrature_boundary->size() << std::endl;
  }

  pcout << "-----------------------------------------------" << std::endl;

  // Initialize the DoF handler.
  {
    pcout << "Initializing the DoF handler" << std::endl;

    dof_handler.reinit(mesh);
    dof_handler.distribute_dofs(*fe);

    locally_owned_dofs = dof_handler.locally_owned_dofs();
    DoFTools::extract_locally_relevant_dofs(dof_handler, locally_relevant_dofs);

    pcout << "  Number of DoFs = " << dof_handler.n_dofs() << std::endl;

    // MODIFIED FROM HERE
    // // Count the number of boundary DoFs.
    // dof_handler.n_boundary_dofs();
    // pcout << "  Number of boundary Dofs = " << dof_handler.n_boundary_dofs() << std::endl;

    // // Count the number of internal DoFs that will be Nh.
    // unsigned int n_internal_dofs = dof_handler.n_dofs() - dof_handler.n_boundary_dofs();
    // pcout << "  Number of internal Dofs = " << n_internal_dofs << std::endl;

    // // Try to extract the boundary DoFs.
    // // https://www.dealii.org/current/doxygen/deal.II/namespaceDoFTools.html#a06b3c33925c1a1f15de20deda20b4d21
    // const ComponentMask component_mask = ComponentMask();
    // const std::set<types::boundary_id> boundary_ids = {0, 1, 2, 3}; // #include <set>
    // const IndexSet boundary_dofs = DoFTools::extract_boundary_dofs(dof_handler, component_mask, boundary_ids);
    // std::vector<types::global_dof_index> boundary_dofs_idx;

    // for (auto it = boundary_dofs.begin(); it != boundary_dofs.end(); it++)
    //   boundary_dofs_idx.push_back(*it);

    // pcout << "  Check boundary_dofs_idx.size()    = " << boundary_dofs_idx.size() << std::endl;
    // for (const auto& dof : boundary_dofs_idx)
    //   pcout << "    " << dof << std::endl;
    // pcout << std::endl;

    // boundary_dofs_idx_int.assign(boundary_dofs_idx.begin(), boundary_dofs_idx.end());
    // pcout << "  Check boundary_dofs_idx_int.size() = " << boundary_dofs_idx_int.size() << std::endl;
    // TO HERE
  }

  pcout << "-----------------------------------------------" << std::endl;

  // Initialize the linear system.
  {
    pcout << "Initializing the linear system" << std::endl;

    pcout << "  Initializing the sparsity pattern" << std::endl;

    TrilinosWrappers::SparsityPattern sparsity(locally_owned_dofs,
                                               MPI_COMM_WORLD);
    DoFTools::make_sparsity_pattern(dof_handler, sparsity);
    sparsity.compress();

    pcout << "  Initializing the matrices" << std::endl;
    mass_matrix.reinit(sparsity);
    stiffness_matrix.reinit(sparsity);
    lhs_matrix.reinit(sparsity);
    rhs_matrix.reinit(sparsity);

    pcout << "  Initializing the system right-hand side" << std::endl;
    system_rhs.reinit(locally_owned_dofs, MPI_COMM_WORLD);
    pcout << "  Initializing the solution vector" << std::endl;
    solution_owned.reinit(locally_owned_dofs, MPI_COMM_WORLD);
    solution.reinit(locally_owned_dofs, locally_relevant_dofs, MPI_COMM_WORLD);
  }
}

void
AdvDiff::assemble_matrices()
{
  pcout << "===============================================" << std::endl;
  pcout << "Assembling the system matrices" << std::endl;

  const unsigned int dofs_per_cell = fe->dofs_per_cell;
  const unsigned int n_q           = quadrature->size();

  FEValues<dim> fe_values(*fe,
                          *quadrature,
                          update_values | update_gradients |
                            update_quadrature_points | update_JxW_values);

  // FEFaceValues<dim> fe_values_boundary(*fe,
  //                                      *quadrature_boundary,
  //                                      update_values |
  //                                        update_quadrature_points |
  //                                        update_JxW_values);

  FullMatrix<double> cell_mass_matrix(dofs_per_cell, dofs_per_cell);
  FullMatrix<double> cell_stiffness_matrix(dofs_per_cell, dofs_per_cell);

  std::vector<types::global_dof_index> dof_indices(dofs_per_cell);

  mass_matrix      = 0.0;
  stiffness_matrix = 0.0;

  for (const auto &cell : dof_handler.active_cell_iterators())
    {
      if (!cell->is_locally_owned())
        continue;

      fe_values.reinit(cell);

      cell_mass_matrix      = 0.0;
      cell_stiffness_matrix = 0.0;

      for (unsigned int q = 0; q < n_q; ++q)
        {
          // Evaluate coefficients on this quadrature node.
          const double mu_loc   = mu.value(fe_values.quadrature_point(q));

          // Evaluate the transport term on this quadrature node.
          Vector<double> beta_vector(dim);
          beta.vector_value(fe_values.quadrature_point(q), beta_vector);

          // Convert the transport term to a tensor (so that we can use it with
          // scalar_product).
          Tensor<1, dim> beta_tensor;
          for (unsigned int i = 0; i < dim; ++i)
            beta_tensor[i] = beta_vector[i];
          
          for (unsigned int i = 0; i < dofs_per_cell; ++i)
            {
              for (unsigned int j = 0; j < dofs_per_cell; ++j)
                {
                  cell_mass_matrix(i, j) += fe_values.shape_value(i, q) *
                                            fe_values.shape_value(j, q) /
                                            deltat * fe_values.JxW(q);

                  cell_stiffness_matrix(i, j) +=
                    mu_loc * fe_values.shape_grad(i, q) *
                    fe_values.shape_grad(j, q) * fe_values.JxW(q);

                  // Transport term.
                  cell_stiffness_matrix(i, j) += 
                    scalar_product(beta_tensor, fe_values.shape_grad(j, q)) *
                    fe_values.shape_value(i, q) * fe_values.JxW(q);
                    
                }
            }
        }

      cell->get_dof_indices(dof_indices);

      mass_matrix.add(dof_indices, cell_mass_matrix);
      stiffness_matrix.add(dof_indices, cell_stiffness_matrix);
    }

  mass_matrix.compress(VectorOperation::add);
  stiffness_matrix.compress(VectorOperation::add);

  // We build the matrix on the left-hand side of the algebraic problem (the one
  // that we'll invert at each timestep).
  lhs_matrix.copy_from(mass_matrix);
  lhs_matrix.add(theta, stiffness_matrix);

  // We build the matrix on the right-hand side (the one that multiplies the old
  // solution un).
  rhs_matrix.copy_from(mass_matrix);
  rhs_matrix.add(-(1.0 - theta), stiffness_matrix);
}

void
AdvDiff::assemble_rhs(const double &time)
{
  const unsigned int dofs_per_cell = fe->dofs_per_cell;
  const unsigned int n_q           = quadrature->size();

  FEValues<dim> fe_values(*fe,
                          *quadrature,
                          update_values | update_quadrature_points |
                            update_JxW_values);

  Vector<double> cell_rhs(dofs_per_cell);

  std::vector<types::global_dof_index> dof_indices(dofs_per_cell);

  system_rhs = 0.0;

  for (const auto &cell : dof_handler.active_cell_iterators())
    {
      if (!cell->is_locally_owned())
        continue;

      fe_values.reinit(cell);

      cell_rhs = 0.0;

      for (unsigned int q = 0; q < n_q; ++q)
        {
          // We need to compute the forcing term at the current time (tn+1) and
          // at the old time (tn). deal.II Functions can be computed at a
          // specific time by calling their set_time method.

          // Compute f(tn+1)
          forcing_term.set_time(time);
          const double f_new_loc =
            forcing_term.value(fe_values.quadrature_point(q));

          // Compute f(tn)
          forcing_term.set_time(time - deltat);
          const double f_old_loc =
            forcing_term.value(fe_values.quadrature_point(q));

          for (unsigned int i = 0; i < dofs_per_cell; ++i)
            {
              cell_rhs(i) += (theta * f_new_loc + (1.0 - theta) * f_old_loc) *
                             fe_values.shape_value(i, q) * fe_values.JxW(q);
            }
        }

      cell->get_dof_indices(dof_indices);
      system_rhs.add(dof_indices, cell_rhs);
    }

  system_rhs.compress(VectorOperation::add);

  // Add the term that comes from the old solution.
  rhs_matrix.vmult_add(system_rhs, solution_owned);
  
  // Boundary conditions.
  {
    std::map<types::global_dof_index, double> boundary_values;

    std::map<types::boundary_id, const Function<dim> *> boundary_functions;

    boundary_functions[0] = &function_g;
    boundary_functions[1] = &function_g;

    VectorTools::interpolate_boundary_values(dof_handler,
                                             boundary_functions,
                                             boundary_values);

    MatrixTools::apply_boundary_values(
      boundary_values, lhs_matrix, solution_owned, system_rhs, false);
  }
}

void
AdvDiff::solve_time_step()
{
  SolverControl solver_control(1000, 1e-6 * system_rhs.l2_norm());

  SolverCG<TrilinosWrappers::MPI::Vector> solver(solver_control);
  TrilinosWrappers::PreconditionSSOR      preconditioner;
  preconditioner.initialize(
    lhs_matrix, TrilinosWrappers::PreconditionSSOR::AdditionalData(1.0));

  solver.solve(lhs_matrix, solution_owned, system_rhs, preconditioner);
  pcout << "  " << solver_control.last_step() << " CG iterations" << std::endl;

  solution = solution_owned;
}

void
AdvDiff::assemble_snapshot_matrix(const unsigned int &time_step)
{
  // At the first call, it is useful to resize the snapshot matrix so that it can be easily filled. It has as many rows as the
  // solution size and as many columns as the number of time steps.
  if(time_step == 0) {
    snapshot_matrix.resize(solution.size());
    for(auto &row : snapshot_matrix)
      row.resize(T/(deltat*sample_every)+1, 0.0); // COSI SAREBBE INIZIALE + 25 SNAPSHOTS OGNI 200 ISTANTI TEMPORALI
  }

  // It is not necessarily to build a snapshot_array, since snapshot_matrix can be directly filled with solution.
  // The idea of a snapshot_array helps in understanding that the snapshot_matrix will be filled with column vectors that
  // represent the solution at each time step.
  // std::vector<double> snapshot_array(solution.size());
  // for (unsigned int i=0; i<solution.size(); i++)
  //   snapshot_array[i] = solution[i];
  // pcout << "  Check solution.size()       = " << solution.size() << std::endl;
  // pcout << "  Check snapshot_array.size() = " << snapshot_array.size() << std::endl;

  for (unsigned int i=0; i<solution.size(); i++)
    snapshot_matrix[i][time_step/sample_every] = solution[i];
}

// void
// AdvDiff::assemble_system_rhs_matrix(const unsigned int &time_step)
// {
//   // At the first call, it is useful to resize the snapshot matrix so that it can be easily filled. It has as many rows as the
//   // solution size and as many columns as the number of time steps.
//   if(time_step == 0) {
//     system_rhs_matrix.resize(system_rhs.size());
//     for(auto &row : system_rhs_matrix)
//       row.resize(T/deltat, 0.0);
//   }

//   // It is not necessarily to build a snapshot_array, since snapshot_matrix can be directly filled with solution.
//   // The idea of a snapshot_array helps in understanding that the snapshot_matrix will be filled with column vectors that
//   // represent the solution at each time step.
//   // std::vector<double> snapshot_array(solution.size());
//   // for (unsigned int i=0; i<solution.size(); i++)
//   //   snapshot_array[i] = solution[i];
//   // pcout << "  Check solution.size()       = " << solution.size() << std::endl;
//   // pcout << "  Check snapshot_array.size() = " << snapshot_array.size() << std::endl;

//   for (unsigned int i=0; i<system_rhs.size(); i++)
//     system_rhs_matrix[i][time_step] = system_rhs[i];
// }

void
AdvDiff::output(const unsigned int &time_step) const
{
  DataOut<dim> data_out;
  data_out.add_data_vector(dof_handler, solution, "u");

  std::vector<unsigned int> partition_int(mesh.n_active_cells());
  GridTools::get_subdomain_association(mesh, partition_int);
  const Vector<double> partitioning(partition_int.begin(), partition_int.end());
  data_out.add_data_vector(partitioning, "partitioning");

  data_out.build_patches();

  data_out.write_vtu_with_pvtu_record(
    "./", "output", time_step, MPI_COMM_WORLD, 3);
}

void
AdvDiff::solve()
{
  assemble_matrices();

  pcout << "===============================================" << std::endl;

  // Apply the initial condition.
  {
    pcout << "Applying the initial condition" << std::endl;

    VectorTools::interpolate(dof_handler, u_0, solution_owned);
    solution = solution_owned;

    // Output the initial solution.
    output(0);
    // if (initial_state.empty())
    // {
      assemble_snapshot_matrix(0);
      // assemble_system_rhs_matrix(0);
    // }
    pcout << "-----------------------------------------------" << std::endl;
  }

  unsigned int time_step = 0;
  double       time      = 0;

  while (time < T && time_step < floor(T/deltat))
    {
      time += deltat;
      ++time_step;

      pcout << "n = " << std::setw(3) << time_step << ", t = " << std::setw(5)
            << time << ":" << std::flush;

      assemble_rhs(time);
      solve_time_step();
      // if(initial_state.empty())
      // {
      if (time_step % sample_every == 0)
      {
        assemble_snapshot_matrix(time_step);
      }
      // assemble_system_rhs_matrix(time_step);
      // }
      output(time_step);
    }
}

// double
// AdvDiff::compute_error(const VectorTools::NormType &norm_type)
// {
//   FE_Q<dim> fe_linear(1);
//   MappingFE mapping(fe_linear);

//   const QGauss<dim> quadrature_error = QGauss<dim>(r + 2);

//   exact_solution.set_time(time);

//   Vector<double> error_per_cell;
//   VectorTools::integrate_difference(mapping,
//                                     dof_handler,
//                                     solution,
//                                     exact_solution,
//                                     error_per_cell,
//                                     quadrature_error,
//                                     norm_type);

//   const double error =
//     VectorTools::compute_global_error(mesh, error_per_cell, norm_type);

//   return error;
// }

#ifndef ADV_DIFF_1D_POD_HPP
#define ADV_DIFF_1D_POD_HPP

/**
 * The aim of this class is to solve the advection diffusion reduced order problem in 1D.
 */

#include <deal.II/base/conditional_ostream.h>
#include <deal.II/base/quadrature_lib.h>

#include <deal.II/distributed/fully_distributed_tria.h>

#include <deal.II/dofs/dof_handler.h>
#include <deal.II/dofs/dof_tools.h>

#include <deal.II/fe/fe_q.h>
#include <deal.II/fe/fe_system.h>
#include <deal.II/fe/fe_values.h>
#include <deal.II/fe/fe_values_extractors.h>
#include <deal.II/fe/mapping_fe.h>

#include <deal.II/grid/grid_generator.h>
#include <deal.II/grid/grid_out.h>
#include <deal.II/grid/tria.h>
#include <deal.II/grid/grid_in.h>

#include <deal.II/lac/dynamic_sparsity_pattern.h>
#include <deal.II/lac/solver_cg.h>
#include <deal.II/lac/trilinos_precondition.h>
#include <deal.II/lac/trilinos_sparse_matrix.h>
// #include <deal.II/lac/full_matrix.h>

#include <deal.II/numerics/data_out.h>
#include <deal.II/numerics/matrix_tools.h>
#include <deal.II/numerics/vector_tools.h>

#include <deal.II/base/parameter_handler.h> // https://www.dealii.org/current/doxygen/deal.II/classParameterHandler.html

#include <filesystem>
#include <fstream>
#include <iostream>
#include <set>

// #include <Eigen/Dense>
// #include <unsupported/Eigen/MatrixFunctions>
// #include <Eigen/Sparse>
// #include <unsupported/Eigen/SparseExtra>

// using Mat_m = Eigen::MatrixXd;
// using Vec_v = Eigen::VectorXd;

using namespace dealii;

// Class representing the linear diffusion problem.
class AdvDiffPOD
{
public:
  // Physical dimension (1D, 2D, 3D)
  static constexpr unsigned int dim = 1;

  // Diffusion coefficient.
  class DiffusionCoefficient : public Function<dim>
  {
  public:
    // Constructor.
    DiffusionCoefficient()
    {}

    // Evaluation.
    virtual double
    value(const Point<dim> & p,
          const unsigned int /*component*/ = 0) const override
    {
      // return std::pow(p[0], 4);
      // return p[0];
      return 0.01;
    }
  };

  // Reaction coefficient.
  // class ReactionCoefficient : public Function<dim>
  // {
  // public:
  //   // Constructor.
  //   ReactionCoefficient()
  //   {}

  //   // Evaluation.
  //   virtual double
  //   value(const Point<dim> & /*p*/,
  //         const unsigned int /*component*/ = 0) const override
  //   {
  //     return 1.0;
  //   }
  // };

  // Transport coefficient.
  class TransportCoefficient : public Function<dim>
  {
  public:
    // Constructor.
    TransportCoefficient()
    {}

    // Evaluation.
    virtual void
    vector_value(const Point<dim> & /*p*/,
                 Vector<double> &values) const override
    {
      // values[0] = 2.0;
      values[0] = 0.2;
    }

    virtual double
    value(const Point<dim> & /*p*/,
          const unsigned int component = 0) const override
    {
      if (component == 0)
        // return 2.0;
        return 0.2;
      else
        return 0.0;
    }
  };

  // Forcing term.
  class ForcingTerm : public Function<dim>
  {
  public:
    // Constructor.
    ForcingTerm()
    {}

    // Evaluation.
    virtual double
    value(const Point<dim> & /*p*/,
          const unsigned int /*component*/ = 0) const override
    {
      return 0.0;
    }
  };

    // Dirichlet boundary conditions.
  class FunctionG : public Function<dim>
  {
  public:
    // Constructor.
    FunctionG()
    {}

    // Evaluation.
    virtual double
    value(const Point<dim> &/*p*/,
          const unsigned int /*component*/ = 0) const override
    {
      return 0.0;
    }
  };

  // Neumann boundary conditions.
  // class FunctionH : public Function<dim>
  // {
  // public:
  //   // Constructor.
  //   FunctionH()
  //   {}

  //   // Evaluation:
  //   virtual double
  //   value(const Point<dim> &/*p*/,
  //         const unsigned int /*component*/ = 0) const override
  //   {
  //     return 0.0;
  //   }
  // };

  // Function for the initial condition.
  class FunctionU0 : public Function<dim>
  {
  public:
    // Constructor.
    FunctionU0()
    {}

    // FunctionU0(const std::vector<double> initial_state) : u0(initial_state)
    // {}

    // Evaluation.
    virtual double
    value(const Point<dim> & p,
          const unsigned int /*component*/ = 0) const override
    {
      // if (u0.empty())
        return std::sin(M_PI*p[0]);
        // return 2.0*std::sin(9.0*M_PI*p[0]) - std::sin(4.0*M_PI*p[0]);
      // else
      // { // QUESTO SICURAMENTE NON CORRETTO
      //   for (unsigned int i = 0; i < u0.size(); ++i)
      //     return u0[i];
      // }
      //   // return u0 * p[0];
    }

    // private:
    //   std::vector<double> u0;

    // // Evaluation.
    // virtual double
    // value(const Point<dim> &p,
    //       const unsigned int /*component*/ = 0) const override
    // {
    //   if (initial_state.empty())
    //     return std::sin(M_PI*p[0]);
    //   else
    //     return initial_state;
    // }
  };

  // Exact solution.
  // class ExactSolution : public Function<dim>
  // {
  // public:
  //   // Constructor.
  //   ExactSolution()
  //   {}

  //   // Evaluation.
  //   virtual double
  //   value(const Point<dim> &p,
  //         const unsigned int /*component*/ = 0) const override
  //   {
  //     return std::cos(M_PI*p[0]) * std::exp(-this->get_time());
  //   }

  //   // Gradient evaluation.
  //   virtual Tensor<1, dim>
  //   gradient(const Point<dim> &p,
  //            const unsigned int /*component*/ = 0) const override
  //   {
  //     Tensor<1, dim> result;

  //     // duex / dx
  //     result[0] = -M_PI * std::sin(M_PI * p[0]) * std::exp(-this->get_time());
  //     result[0] =
  //       std::exp(p[0]) * (std::exp(p[1])-1);
  //     result[1] =
  //       std::exp(p[1]) * (std::exp(p[0])-1);
  //     return result;
  //   }
  // };

  // Default constructor.
  AdvDiffPOD(const unsigned int N_,
             const unsigned int &r_,
             const double       &T_,
             const double       &deltat_,
             const double       &theta_,
             const std::vector<std::vector<double>> &snapshot_matrix_,
             const std::vector<std::vector<double>> &modes_)
    : mpi_size(Utilities::MPI::n_mpi_processes(MPI_COMM_WORLD))
    , mpi_rank(Utilities::MPI::this_mpi_process(MPI_COMM_WORLD))
    , pcout(std::cout, mpi_rank == 0)
    , T(T_)
    , N(N_)
    , r(r_)
    , deltat(deltat_)
    , theta(theta_)
    , modes(modes_)
    , snapshot_matrix(snapshot_matrix_)
    , mesh(MPI_COMM_WORLD)
    , mesh_r(MPI_COMM_WORLD)
  {}

  // Initialization.
  void
  setup();

  // Solve the problem.
  void
  solve_reduced();

  // Compute the error for convergence analysis.
  // double
  // compute_error(const VectorTools::NormType &norm_type);

  // Boundary DOFs indices.
  // std::vector<unsigned int> boundary_dofs_idx_int;

  // HAI SPOSTATO TU PER RIPROIEZIONE IN MAIN poi eventualmente sposta poiezione di qui
  // System solution (including ghost elements).
  // TrilinosWrappers::MPI::Vector solution; 
  TrilinosWrappers::MPI::Vector reduced_solution; 

protected:
  // Setup the reduced system.
  void
  setup_reduced();

  // Assemble the mass and stiffness matrices.
  void
  assemble_matrices();

  // Assemble the right-hand side of the problem.
  void
  assemble_rhs(const double &time, TrilinosWrappers::SparseMatrix &snapshot_matrix_trilinos);

  // Assemble the right-hand side of the problem.  ..... altrimenti serve solution_owned
  void
  assemble_reduced_rhs(const double &time);

  // Project the full order system to the reduced order system thanks to the transformation matrix.
  void
  convert_modes(TrilinosWrappers::SparseMatrix &transformation_matrix);

  void
  project_u0(TrilinosWrappers::SparseMatrix &transformation_matrix);

  void
  project_lhs(TrilinosWrappers::SparseMatrix &transformation_matrix);

  void
  project_rhs(TrilinosWrappers::SparseMatrix &transformation_matrix);

  void
  project_rhs_matrix(TrilinosWrappers::SparseMatrix &transformation_matrix);

  // Solve the problem for one time step.
  void
  solve_time_step_reduced();

  // Output.
  void
  output(const unsigned int &time_step) const;

  // MPI parallel. /////////////////////////////////////////////////////////////

  // Number of MPI processes.
  const unsigned int mpi_size;

  // This MPI process.
  const unsigned int mpi_rank;

  // Parallel output stream.
  ConditionalOStream pcout;

  // Problem definition. ///////////////////////////////////////////////////////

  // Diffusion coefficient.
  DiffusionCoefficient mu;

  // Reaction coefficient.
  // ReactionCoefficient reaction_coefficient;

  // Transport coefficient.
  TransportCoefficient beta;

  // Forcing term.
  ForcingTerm forcing_term;

  // g(x).
  FunctionG function_g;

  // Initial condition.
  FunctionU0 u_0;

  // Initial ROM state.
  // const std::vector<double> initial_state;

  // h(x).
  // FunctionH function_h;

  // Exact solution.
  // ExactSolution exact_solution;

  // Current time.
  double time;
  
  // Final time.
  const double T;

  // Number of elements.
  const unsigned int N;

  // Discretization. ///////////////////////////////////////////////////////////

  // Polynomial degree.
  const unsigned int r;

  // Time step.
  const double deltat;

  // Theta parameter of the theta method.
  const double theta;

  // Projection. ///////////////////////////////////////////////////////////

  // La metti qui per proiezione nel senso che serve solution_owned, ma è okay? ha senso? rende il codice riproducibile?
  const std::vector<std::vector<double>> snapshot_matrix; 
  // TrilinosWrappers::SparseMatrix snapshot_matrix_trilinos;

  // Transformation matrix.
  const std::vector<std::vector<double>> modes;
  // TrilinosWrappers::SparseMatrix transformation_matrix;
  // FullMatrix<double> transformation_matrix; // (modes.size(), modes[0].size());

// for (unsigned int i = 0; i < modesT.m(); ++i)
//     for (unsigned int j = 0; j < modesT.n(); ++j)
//         modesT(i, j) = modesT_vec[i][j];

// dealii::FullMatrix<double> modes(modes_vec.size(), modes_vec[0].size());
// for (unsigned int i = 0; i < modes.m(); ++i)
//     for (unsigned int j = 0; j < modes.n(); ++j)
//         modes(i, j) = modes_vec[i][j];


  // Mesh.
  parallel::fullydistributed::Triangulation<dim> mesh;

  // Reduced mesh.
  parallel::fullydistributed::Triangulation<dim> mesh_r;

  // Finite element space.
  std::unique_ptr<FiniteElement<dim>> fe;

  // Finite element space for reduced system.
  std::unique_ptr<FiniteElement<dim>> fe_r;

  // Quadrature formula.
  std::unique_ptr<Quadrature<dim>> quadrature;

  // Quadrature formula for reduced system.
  std::unique_ptr<Quadrature<dim>> quadrature_r;

  // Quadrature formula used on boundary lines.
  std::unique_ptr<Quadrature<dim - 1>> quadrature_boundary;

  // DoF handler.
  DoFHandler<dim> dof_handler;

  // DoF handler for reduced system.
  DoFHandler<dim> dof_handler_r;

  // DoFs owned by current process.
  IndexSet locally_owned_dofs;

  // DoFs owned by current process. .........
  IndexSet locally_owned_dofs_r;

  // DoFs relevant to the current process (including ghost DoFs).
  IndexSet locally_relevant_dofs;

  // DoFs relevant to the current process (including ghost DoFs). ........
  IndexSet locally_relevant_dofs_r;

  // ...
  // IndexSet modes_idx;

  // Mass matrix M / deltat.
  TrilinosWrappers::SparseMatrix mass_matrix;

  // Stiffness matrix A.
  TrilinosWrappers::SparseMatrix stiffness_matrix;

  // Matrix on the left-hand side (M / deltat + theta A).
  TrilinosWrappers::SparseMatrix lhs_matrix;
  TrilinosWrappers::SparseMatrix reduced_system_lhs;

  // Matrix on the right-hand side (M / deltat - (1 - theta) A).
  TrilinosWrappers::SparseMatrix rhs_matrix;
  TrilinosWrappers::SparseMatrix reduced_rhs_matrix;

  // Right-hand side vector in the linear system.
  TrilinosWrappers::MPI::Vector system_rhs;
  TrilinosWrappers::MPI::Vector reduced_system_rhs;

  // ... qui eventualmente togli se puoi evitare u_0
  // però mi sa che devi moltiplicare per V la condizione iniziale e allora potresti fare project_solutionowned
  TrilinosWrappers::SparseMatrix reduced_u_0;

  // System solution (without ghost elements).
  TrilinosWrappers::MPI::Vector solution_owned;

  // System solution (without ghost elements).
  TrilinosWrappers::MPI::Vector reduced_solution_owned; // che è praticamente usata per condizione iniziale ridotta

};

#endif
  
  
  
  
  
  // NOTE: boundary_dofs_idx_int and snapshot_array are public members, the other arguments are protected members 
    AdvDiff problem(N, r, T, deltat, theta);    

    problem.setup();
    problem.solve();

    // Now the snapshot_matrix, defined with standard library, is required to fit in snapshots, defined in Eigen, since the SVD
    // method is implemented in Eigen.
    // size_t snapshot_length = problem.snapshot_matrix.size();
    // size_t time_steps = problem.snapshot_matrix[0].size();
    // Mat_m snapshots = Mat_m::Zero(snapshot_length, time_steps);
    // for (size_t i=0; i<snapshots.rows(); i++)
    //   for (size_t j=0; j<snapshots.cols(); j++)
    //     snapshots(i, j) = problem.snapshot_matrix[i][j];

    // if (mpi_rank == 0) {
    //   std::cout << "\nCheck dimensions of snapshots: "
    //             << snapshots.rows() << " * " << snapshots.cols() << std::endl << std::endl;
    // }

      // std::cout << "===============================================" << std::endl;
      // std::cout << "Compute POD modes" << std::endl;

      // // Initialize the vector sigma to store the singular values
      // int rank = std::min(snapshots.rows(), snapshots.cols());
      // Vec_v sigma = Vec_v::Zero(rank);

      // // Initialize the other inputs required by the SVD method, Note that the SVD method returns sigma as a vector, then it has
      // // to be converted into a diagonal matrix
      // Mat_m U = Mat_m::Zero(snapshots.rows(), snapshots.rows());
      // Mat_m V = Mat_m::Zero(snapshots.cols(), snapshots.cols());

      // SVD(snapshots, sigma, U, V, rank);
      // std::cout << "\nCheck dimensions of U:     " << U.rows() << " * " << U.cols() << endl;
      // std::cout << "Check dimensions of sigma: " << sigma.size() << endl;
      // std::cout << "Check dimensions of V:     " << V.rows() << " * " << V.cols() << endl;

      std::cout << "===============================================" << std::endl;
      std::cout << "Construct and run ROM" << std::endl;

      const double deltat_rom = 1e-3; // CAMBIA
      std::vector<size_t> rom_sizes = {2, 4, 6}; 
      // Mat_m modes;

      for (size_t i=0; i<rom_sizes.size(); i++) {
        std::cout << "  Creating ROM for " << rom_sizes[i] << " modes" << std::endl;
        // modes.resize(U.rows(), rom_sizes[i]);
        // modes = U.leftCols(rom_sizes[i]);

        // Projection of the initial FOM state on the ROM basis
        // Vec_v rom_initial_state = modes.transpose() * snapshots.col(0);
        // if (rom_initial_state.size() == rom_sizes[i])
        //   std::cout << "  Check dimensions of rom_state: " << rom_initial_state.size() << std::endl;
        // else
        //   std::cerr << "  Error in computing rom_state" << std::endl;
        
        // std::vector<double> initial_state(rom_sizes[i]);
        // for(size_t j=0; j<rom_sizes[i]; j++)
        //   initial_state[i] = rom_initial_state(j);

        // USARE rom_state COME CONDIZIONE INIZIALE PER IL ROM? vedi nota ?????????
        // USARE romsize come N???????

        // MODES SAREBBE V SUL LIBRO
        AdvDiffPOD problemPOD(N, r, T, deltat_rom, theta, rom_sizes[i], modes);    

        problemPOD.setup();
        problemPOD.solve();

        // The final ROM state corresponds to the solution of the ROM problem.
        // Vec_v rom_final_state = Vec_v::Zero(rom_sizes[i]);
        // for(size_t j=0; j<rom_sizes[i]; j++)
        //   rom_final_state(j) = problemPOD.solution[j];

        // Reconstruction of the FOM state from the final ROM state
        // Vec_v fom_state = modes * rom_final_state;
      }

      // fomReferenceState per te è ?
      // fomInitialState per te è snapshots[:, 0)





          // std::vector<double> initial_state(rom_sizes[i]);
    // for(size_t j=0; j<rom_sizes[i]; j++)
    //   initial_state[i] = rom_initial_state(j);

        // USARE rom_state COME CONDIZIONE INIZIALE PER IL ROM? vedi nota ?????????
        // USARE romsize come N???????

        // MODES SAREBBE V SUL LIBRO
        // AdvDiffPOD problemPOD(N, r, T, deltat_rom, theta, modes);    

        // problemPOD.setup();
        // problemPOD.solve();

        // RISOLUZIONE
        // ? fom reference state?
  //         # create problem
  // scheme = ode.stepscheme.ForwardEuler
  // problem = rom.galerkin.DefaultExplicitProblem(scheme, fomObj, linearDecoder, romState, fomReferenceState)

  // # create object to monitor the romState at every iteration
  // myObs = RomStateObserver()
  // # solve problem
  // ode.advance_n_steps_and_observe(problem, romState, 0., dt, nsteps, myObs)


      // Time-stepping parameters
    // double dt = 0.01;
    // int nsteps = 100;

    // // Time-stepping loop
    // for (int step = 0; step < nsteps; ++step) {
    //     // Compute the derivative in ROM space (this is problem-specific)
    //     // Here, we assume a simple linear model for illustration
    //     Eigen::VectorXd romDerivative = -romState; // Replace with your actual derivative computation

    //     // Advance the ROM state
    //     romState = advanceOneStep(romState, romDerivative, dt);
    // }

        // Set the reduced order problem with Forward Euler